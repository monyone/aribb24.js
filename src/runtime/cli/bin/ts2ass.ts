import { ARIBB24Parser } from '../../../lib/parser/parser';
import read from '../../../lib/demuxer/mpegts';
import { exit } from '../exit';
import { readableStream, writableStream } from '../stream';
import regioner, { ARIBB24Region, ARIBB24RegionerToken, ARIBB24Span, SSZ_RUBY_DETECTION } from "../../../lib/parser/regioner";
import colortable from '../../common/colortable';
import namedcolor from '../../common/namedcolor';
import { args, ArgsOption, parseArgs } from '../args';
import { ARIBB24CaptionManagement, CaptionAssociationInformation } from '../../../lib/demuxer/b24/datagroup';
import { getTokenizeInformation } from '../info';
import { writeFS } from '../file';

const timestamp = (seconds: number): string => {
  const mill10 = Math.floor(seconds * 100) - Math.floor(seconds) * 100;
  const sec = Math.floor(seconds) % 60;
  const min = Math.floor(seconds / 60) % 60;
  const hour = Math.floor(seconds / 3600) % 60;

  return `${hour}:${min.toString(10).padStart(2, '0')}:${sec.toString(10).padStart(2, '0')}.${mill10.toString(10).padStart(2, '0')}`;
}
const color = (color: string | number) => {
  if (typeof color === 'number') {
    color = colortable[color];
  }
  if (namedcolor.has(color)) {
    color = namedcolor.get(color)!;
  }
  color = color.toLowerCase();
  const r = color.slice(1, 3);
  const g = color.slice(3, 5);
  const b = color.slice(5, 7);
  return `${b}${g}${r}`;
};

const textize_token = (token: ARIBB24RegionerToken): string => {
  switch (token.tag) {
    case 'Character': return token.character;
    case 'DRCS': return 'ã€“';
    case 'Script': return textize_token(token.sup) + textize_token(token.sub);
  }
}
const texize_span = (span: ARIBB24Span): string => {
  let previous_color = null;
  let result = '';
  for (const token of span.text) {
    switch (token.tag) {
      case 'Character':
      case 'DRCS':
        if (previous_color !== token.state.foreground) {
          previous_color = token.state.foreground;
          result += `\{\\c${color(token.state.foreground)}&\}`
        }
        result += textize_token(token);
        break;
      case 'Script': {
        for (const script of [token.sup, token.sub])
        {
          if (previous_color !== script.state.foreground) {
            previous_color = script.state.foreground;
            result += `\{\\c${color(script.state.foreground)}&\}`
          }
          result += textize_token(script);
          break;
        }
      }
    }
  }
  return result;
}
const textize_region = (region: ARIBB24Region): string => {
  const r = region.size === 'Middle' ? 'MSZ' : region.size === 'Small' ? 'SSZ' : 'NSZ';
  const x = region.margin[0] + region.position[0];
  const y = region.margin[1] + region.position[1];
  return `\{\\r${r}\}` + `\{\\pos(${x},${y})\}` + region.spans.map((span) => texize_span(span)).join('');
}

const cmdline = ([
  {
    long: '--input',
    short: '-i',
    help: 'Specify Input File (.ts)',
    action: 'default',
  },
  {
    long: '--output',
    short: '-o',
    help: 'Specify Output File (.ass)',
    action: 'default'
  },
  {
    long: '--title',
    short: '-o',
    help: 'Specify Title',
    action: 'default'
  },
  {
    long: '--font',
    short: '-f',
    help: 'Specify font',
    action: 'default',
  },
  {
    long: '--language',
    short: '-l',
    help: 'Specify language',
    action: 'default',
  },
  {
    long: '--help',
    short: '-h',
    help: 'Show help message',
    action: 'help',
  }
]) as const satisfies ArgsOption[];

(async () => {
  const cmd = parseArgs(args(), cmdline, 'ts2sup', 'MPEG-TS ARIB Caption (Profile A) to SUP (HDMV-PGS)');
  const input = cmd['input'] ?? '-';
  const output = cmd['output'] ?? '-';
  const title = cmd['title'] ?? 'Generated by aribb24.js';
  const font = cmd['font'];
  if (font == null) {
    console.error('Please specify fontname.');
    return exit(-1);
  }
  const language = Number.isNaN(Number.parseInt(cmd['language'])) ? (cmd['language'] ?? 0) : Number.parseInt(cmd['language']);

  let plane = [-1, -1];
  let captions: [begin: number, end: number, regions: ARIBB24Region[]][] = [];
  {
    let management: ARIBB24CaptionManagement | null = null;
    let desired: number | null = null;
    for await (const independent of read(await readableStream(input))) {
      if (independent.tag !== 'Caption') { continue; }

      const caption = independent.data;
      if (caption.tag === 'CaptionManagement') {
        if (typeof(language) === 'number') {
          desired = language;
        } else {
          const lang = [... caption.languages].sort(({ lang: fst }, { lang: snd}) => fst - snd).filter(({ iso_639_language_code }) => iso_639_language_code === language);
          desired = lang?.[0]?.lang ?? null;
        }
        management = caption;
      } else if (management == null) {
        continue;
      } else {
        const entry = management.languages.find((entry) => entry.lang === caption.lang);
        if (entry == null) { continue; }
        if (desired !== caption.lang) { continue; }

        const specification = getTokenizeInformation(entry.iso_639_language_code, entry.TCS, 'UNKNOWN');
        if (specification == null) { continue; }
        const [association, tokenizer, state] = specification;
        const parser = new ARIBB24Parser(state, { magnification: 2 });
        const info = {
          association,
          language: entry.iso_639_language_code,
        };

        const tokens = parser.parse(tokenizer.tokenize(independent.data));
        let elapsed_time = 0;
        for (const token of tokens) {
          if (token.tag === 'ClearScreen') {
            elapsed_time = token.time;
          }
        }

        captions.push([independent.pts, elapsed_time ===  0 ? Number.POSITIVE_INFINITY : independent.pts + elapsed_time, regioner(tokens, info, SSZ_RUBY_DETECTION.PRESERVE)]);
        plane = parser.currentState().plane;
      }
    }
  }

  for (let i = 0; i < captions.length - 1; i++) {
    if (Number.isFinite(captions[i][1])) { continue; }
    captions[i][1] = captions[i + 1][0];
  }
  if (!Number.isFinite(!captions[captions.length - 1][1])) {
    captions.splice(captions.length - 1, 1);
  }

  //
  let ass = '';
  ass += '[Script Info]\n';
  ass += `Title: ${title}\n`;
  ass += 'ScriptType: v4.00+\n';
  ass += `PlayResX: ${plane[0]}\n`;
  ass += `PlayResY: ${plane[1]}\n`;
  ass += 'WrapStyle: 0\n';
  ass += 'ScaledBorderAndShadow: yes\n';
  ass += '\n';
  ass += '[V4+ Styles]\n';
  ass += 'Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding\n';
  ass += 'Style: Normal,Arial,72,&HFFFFFF,&HFFFFFF,&H80000000,&H80000000,0,0,0,0,100,100,0,0,3,24,0,1,0,0,0,0\n';
  ass += 'Style: Middle,Arial,72,&HFFFFFF,&HFFFFFF,&H80000000,&H80000000,0,0,0,0,100,50,0,0,3,24,0,1,0,0,0,0\n';
  ass += 'Style: Small,Arial,36,&HFFFFFF,&HFFFFFF,&H80000000,&H80000000,0,0,0,0,100,100,0,0,3,12,0,1,0,0,0,0\n';
  ass += '\n';
  ass += '[Events]\n';
  ass += 'Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text\n';
  ass += captions.map(([begin, end, regions]) => {
    return regions.map((region) => {
      return `Dialogue: 0,${timestamp(begin)},${timestamp(end)},${region.size},,0,0,0,,{\\an7}${textize_region(region)}`;
    }).join('\n') + '\n';
  }).join('') + '\n';

  writeFS(output, ass);
})();
